//Условные типы и infer
//Условные типы мы уже рассматривали, но просто для повторения и закрепления:
type isString<T> = T extends string ? true : false;
type True = isString<string>;
type False = isString<number>;

/*
  Представим ситуацию, когда нам нужно достать какое-то возращаемое значение из функции, либо аргументы из функции, как это сделать? Конечно, 
  мы можем воспользоваться утилизатрными типами, но как они работают? Тут как раз нам придет на помощь infer, с его помощью мы можем передать
  какие-то динамические аргументы, с динамической типизацией, это значит, что несмотря на то, что мы можем и не знать что там за аргументы
  будут после 10 дней работы и после того, как с этой функией (откуда мы достаем типы) будут взаимодействовать, но мы все равно можем быть
  уверены, что ничего не сломается, т.к. мы передаем динамические значения.

  Мы можем как достать какое-то определенное количество условных аргументов, так и все сразу и я сейчас распишу каждый из способов:
*/

function fn(arg: string, arg2: number): string {
  return "";
}

type MyParameters<T> = T extends (arg: infer U) => any ? U : never;
type NewMyParameters = MyParameters<typeof fn>; //В данном случае мы получим never, так как у нас более одного аргумента

/*
  Если прям расписывать запись, то что мы делаем: мы прокидываем дженерик, т.к. не знаем, какая именно функция будет получена на вход, это может быть 
  как описанная мной выше fn, так и любая другая функция, из которой мы хотим достать аргументы. Далее, с помощью условного типа мы экстендимся 
  от функции, внутрь которой мы указываем аргумент, который хотим достать и там уже пишем infer U, то есть, говорим ts о том, что аргумент может быть
  любой и он может быть динамичным. После чего мы пишем возращаемое значение, в нашем случае это any, так как мы не знаем что может быть в возращаемом значении
  и после чего идет проверка. Если это функция с таким аргументов, то тогда мы возращаем этот самый аргумент (U), если условие не совпадает, то это 
  never - недоступная величина, то, к чему мы не можем прийти. Проще говоря - это либо не та функция (из-за того, что аргументы не с тем неймингом 
  или их разное количество, или это не функция вовсе).

  Если у нас несколько аргументов:
*/

type MyParameters2<T> = T extends (arg: infer U, arg2: infer A) => any
  ? [U, A, A, A, U, U]
  : never;

type NewMyParameters2 = MyParameters2<typeof fn>; //Будет [string, number, number, number, string, string]

//Если у нас динамическое количество аргументов и нужно достать все:

type MyParameters3<T> = T extends (...args: infer U) => any ? U : never;
type NewMyParameters3 = MyParameters3<typeof fn>; //Вернется [arg: string, arg2: number]

//Как достать возращаемое значение

type MyReturnType<T> = T extends (...arg: any) => infer U ? U : never;
type MyNewReturnType = MyReturnType<typeof fn>; //Получи string

/*
  Вообще, я немного неправильно выразился, когда говорил о том, что мы возращаем any, т.к. не знаем что будет на выходе. На самом деле, мы возращаем
  any просто потому, что нас это не интересует, аргументы или возращаемый тип из функции могут поменяться из-за чего может сломаться код, хотя нам
  вроде как вообще не нужны эти аргументы, либо возращаемый тип из функции. Именно поэтому мы указываем any. Потому, что наша цель не достать
  условные аргументы, когда мы хотим достать возращаемый тип из функции и наоборот - если мы хотим достать возращаемый тип из функции, то зачем нам
  аргументы и их типизация?

  Вообще, мы можем вытаскивать такую типизацию с помощью infer не только из функций, а в целом, почти из всего, допустим, из массива:
*/

type TypeArray<T extends any[]> = T extends (infer U)[] ? U : never;
const array: string[] = ["123fcs", "asdasd", "123123"];
type NewTypeArray = TypeArray<typeof array>; //Получим string
