/*
      Литералы - это типы, которые используются как значения. Условно, если мы хотим к конкретной переменной привязать не какой-то определенный тип, а какие-то
      определенные значения, то нужно использовать литералы:
*/
type Color = "red" | "green";
function fn(color: Color) {
  return color;
}
fn("red"); //Можем вернуть только либо red, либо green

/*
      Однако, если в качестве аргумента для функции попытаемся передать объект, то такое действие у нас не получится сделать, все потому, 
      что объект можно менять, но это можно исправить:
*/

type Color2 = "red" | "green";
const value = {
  color: "red",
} as const; //Таким образом мы делаем объект readonly и запрещаем его изменения, из-за чего ts не ругается на то, что мы используем объект как значение для fn2
function fn2(color: Color) {
  return color;
}
fn(value.color);

//Также, подобный readonly можно применить и к типа, и к интерфейсам:

type SomeType = {
  readonly numberPhone: number;
};
interface SomeInterface {
  readonly age: number;
}

//Шаблонные литералы - это такой вид литералов, когда мы задаем какой-то тип данных, а затем шаблоном подставляем его в новый тип и как-то видоизменяем:
type EventsName = "Change" | "Click" | "Range";
type Handler = `on${EventsName}`; //Получается onChange, onClick, onRange
