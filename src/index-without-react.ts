//Разница между type и interface
/*
  Как таковой, разницы особой между ними нет, но есть маленькие детали, которые все же отличаются. Например, если мы хотим задать
  какой-то литерал или, например, алиас с number[], то тогда мы можем воспользоваться только типом, если попробуем воспользоваться интерфейсом,
  то ts будет ругаться на это:
*/
type AliasType = "red" | "green";
type IdType = number[];
// interface AliasInterface = "red" | "green";
// interface IdInterface = number[];

/*
  Также при наследовании будет разный синтаксис. С точки зрения ts - это разные операции, но с точки зрения решения проблемы - результат будет одним и тем
  же:
*/
type Type1 = {
  userName: string;
};
type Type2 = Type1 & {
  //Эта операция называется интерсекшион
  age: number;
};

interface Interface1 {
  userName: string;
}
interface Interface2 extends Interface1 {
  age: number;
}

/*
  Также важно, что если мы создадим 2 интерфейса с одинаковыми именами, то они будут с точки зрения тайпскрипта объединены в один интерфейс и будет 
  доступ сразу и к полям первого интерфейса, и к полям второго интерфейса. Если же мы сделаем такое с типом, то нам вернется ошибка, каждый тип
  будет уникальным
*/

interface Base {
  userName: string;
}
interface Base {
  age: number;
}
const obj: Base = {
  userName: "fweddf",
  age: 12,
};
//Тут даже будет ошибка, если мы не напишем например userName в объект или age

/*
  Также, если мы хотим создать кортеж, то это нужно делать через тип, а не через интерфейс.
  Кортеж - это массив с жестко заданными параметрами, такими как: четко заданный размер массива, четко заданные типы в каждой ячейке массива:
*/
type ArrayType = [number, string, 1];
const obj2: ArrayType = [1, "string", 1]; //Если мы тут в конце вместо 1 напишем 2, то будет ошибка, либо если поменяем тип данных

//Явный пример использования кортежа - это хук useState в React, где нам всегда возращается переменная со значением и также функция:
type useType<T> = [T, (newValue: T) => void];

/*
  Также, если говорить про производительность, то лучше использоваться в этом случае интерфейсом, то есть extends, чем интерсекшином, так как
  под капотом TS будет проводить меньше операций и это более легкая операция.

  Также, если мы задаем какие-то функции в качестве типизации, то лучше использовать Type потому, что такая запись будет просто банально лучше читаться:
*/
type TypeFn = (arg: number) => string;
interface InterfaceFn {
  (arg: number): string;
}

const typeFn: TypeFn = (arg: number /*arg2: string будет ошибка*/) => {
  return "123123";
};
const interfaceFn: InterfaceFn = (arg: number) => {
  return "sdfsdf";
};
