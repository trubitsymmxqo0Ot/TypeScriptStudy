//Перечисления (enum)
/*
  Enum - это по сути обычное перечисление чего-либо, у него есть как свои плюсы и неочивидные моменты, так и свои минусы.
  В целом, вместо enum взять обычный объект и попытаться достать у него ключи через keyof, чтобы использовать его как заменитель enum, такое
  у нас не получится, мы достанем прям целый объект

  Enum бывает нескольких видов, это enum с уже каким-то заранее заданным содержимым:
*/
enum COLOR {
  RED = "red",
  GREEN = "green",
  BLUE = "blue",
}
function setColor(color: COLOR) {
  return color;
}
setColor(COLOR.RED);

/*
  При этом, нам вернется не совсем очевидный код, который будет создан при компиляции ts:

  var COLOR;
  (function (COLOR) {
    COLOR["RED"] = "red";
    COLOR["GREEN"] = "green";
    COLOR["BLUE"] = "blue"
  })(COLOR || (COLOR = {}));
  function setColor(color){
    return color;
  }
  setColor(COLOR.RED);

  Такой код является не то, чтобы не совсем очевидным, а удивительным, учитывая, что компиляция ts заключается только в том, чтобы следить за типизацией 
  данных, а не за формированием кода

  Существует ещё также enum без каких-то заднных значений:
*/

enum COLOR2 {
  RED,
  GREEN,
  BLUE,
}
function setColor2(color: COLOR2) {
  return color;
}
setColor2(COLOR2.GREEN);

/*
  Тут вернется почти такой же код:

  var COLOR2;
  (function (COLOR2) }
    COLOR2[COLOR2["RED"] = 0] = "RED";
    COLOR2[COLOR2["GREEN"] = 1] = "GREEN";
    COLOR2[COLOR2["BLUE"]] = 2] = "BLUE"; 
  })(COLOR2 || (COLOR2 = {}));
  function setColor2(color){
    return color;
  }
  setColor(COLOR2.GREEN);

  Важно заметить, что тут вместо значений идет счёт от 0 и до 2 в нашем случае, однако, если мы, к примеру в GREEN укажем точное значение, например 4, 
  то счет уже будет такой: RED = 0, GREEN = 4, BLUE = 5, то есть, следующий элемент enum будет смотреть на предыдущий и исходя из полученного 
  значения идти дальше по счету
*/

//Также, ещё сущестуют константные энамы

const enum COLOR3 {
  RED = "red",
  GREEN = "green",
  BLUE = "blue",
}

function setColor3(color: COLOR3) {
  return color;
}
setColor3(COLOR3.BLUE);

/*
  Тут код после компиляции будет таким:
  
  function setColor(color){
    return color;
  }
  setColor("blue" /&COLOR3.BLUE&/);

  & - это *, просто я подменил их, т.к. комментарий ломается

  То есть тут уже достается определенное значение сразу же
*/

//Приводим объект к enum. Это можно сделать двумя способами (способ 1 на самом деле, просто отличается стиль записи):
const Color4Obj = {
  RED: "red",
  GREEN: "green",
  BLUE: "blue",
} as const;
type Color4 = (typeof Color4Obj)[keyof typeof Color4Obj];
function fn(color: Color4) {
  return color; //"red" | "green" | "blue"
}

/*
  Тут можно прочитать слева направо, мы сначала у объекта собираем тип, потом у объекта, который мы получили собираем ключи и затем превращаем 
  эти ключи опять в тип.

  Следующая запись делает абсолютно тоже самое, просто она легче читается
*/

type ValueEnum<T> = T[keyof T];
const Color5Obj = {
  RED: "red",
  GREEN: "green",
  BLUE: "blue",
} as const;
type Color5 = ValueEnum<typeof Color5Obj>;
function fn2(color: Color5) {
  return color; //red | green | blue
}
fn2("red");

/*
  Также, в таком решении очень важно для объекта, который мы будем превращать в enum, указывать as const, т.к. если мы этого не сделаем, то в 
  тип получим просто строку. Всё потому, что объект по ссылке можно поменять и конкретные значения в типы превратить не получится. Однако, 
  если мы гарантируем, что этот объект readonly, тогда мы успешно получим в качестве типов значения объекта
*/

/*
  Вот несколько подводных камней enum:

  Если мы создали enum, у которого есть только ключи, но нет к ним значений, то тогда к такому enum мы можем обратить по индексу, как к обычному массиву,
  условно: COLOR2[0], но такое работает только для числовых значений, то есть, если мы укажем какую-то строку, то так обратиться к enum мы не сможем.

  Также, оооочень важно, что если например у нас есть 2 таких типа:

  type Some1 = {
    value: string
  }
  type Some2 = {
    value: string
  }

  Они имеют одинаковые поля и тайпскриптом будут восприниматься как взаимозаменяемые типы, то есть, он примет и тот, и другой тип и проблем с этим не будет.
  То вот у enum работает не так:
  
  enum SOME1 {
    value = 'string'
  }
  enum SOME2 {
    value = 'string'
  }

  Тут они будут уже считаться отдельными типами, которые совершенно не похожи друг на друга. Такое поведение может выстрелить в ногу, т.к. переиспользование
  enum затруднено:
*/

enum ENUM1 {
  color = "red",
}
enum ENUM2 {
  color = "red",
}

function someFn(color: ENUM1) {
  return color;
}
// someFn(ENUM2.color); //Вот это уже будет считаться ошибкой, хотя эти энамы абсолютно одинаковы

/*
  Подведем итоги:
  
  Характеристика              enum      const enum     const objects
  
  Доступность в runtime         Да         Нет             Да
  
  Размер бандла               Больше      Меньше          Меньше
  
  Типизация                   Отличная    Отличная       Требует явного 
                                                            задания
  
  Двусторонеее 
  отображение                   Да          Нет             Нет
  
  Удобство                  Удобно для     Удобно для       Простое и гибкое решение
                            перечислений    констант

            
*/
